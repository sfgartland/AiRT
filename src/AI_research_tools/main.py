from time import sleep
import typer
from typing_extensions import Annotated

from typing import Callable, List, Tuple
from enum import Enum

from loguru import logger

from pathlib import Path

from rich.prompt import Confirm
from rich.live import Live
from rich.progress import Progress
from rich.console import Console

from .UI import template_enum_completer

from .Types import FilePairsType, InputTypes, FileFilters, ToMp3_FileTypes

from .helpers import USER_DIR


#### Logger setup start

console = Console()
logger.remove()


def _log_formatter(record: dict) -> str:
    """Log message formatter"""
    color_map = {
        "TRACE": "dim blue",
        "DEBUG": "cyan",
        "INFO": "bold",
        "SUCCESS": "bold green",
        "WARNING": "yellow",
        "ERROR": "bold red",
        "CRITICAL": "bold white on red",
    }
    lvl_color = color_map.get(record["level"].name, "cyan")
    return (
        "[not bold green]{time:YYYY/MM/DD HH:mm:ss}[/not bold green] | {level.icon}"
        + f"  - [{lvl_color}]{{message}}[/{lvl_color}]"
    )


logger.add(
    console.print,
    level="TRACE",
    format=_log_formatter,
    colorize=True,
)
logger.add(str(USER_DIR)+"/logs/transcriber-{time}.log")

#### Logger setup end


#### Typer setup start

app = typer.Typer()

def import_user_module(path: Path, name: str):
    import importlib
    import sys
    
    spec = importlib.util.spec_from_file_location(name, path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[name] = module
    spec.loader.exec_module(module)

    return module


def add_custom_commands():
    """Imports python files from '.airt' directory and adds the functions prefixed with 'command_' into the custom commands in typer"""
    import glob
    from inspect import getmembers, isfunction

    custom_files = glob.glob(f"{USER_DIR}/*.py")
    for custom_file in custom_files:
        custom_file = Path(custom_file)
        module = import_user_module(custom_file, custom_file.stem)
        functions = getmembers(module, isfunction)


        command_functions = [(x[0].replace("command_", ""), x[1]) for x in functions if "command_" in x[0]]
        custom_app = typer.Typer()
        app.add_typer(custom_app, name="custom", help="Custom commands loaded form userdir")
        for command in command_functions:
            custom_app.command(command[0])(command[1])


add_custom_commands()

#### Typer setup end




def templatePriceEstimate(
    filePairs: FilePairsType, priceEstimateMethod: callable
) -> bool:
    from .UI import genPriceTable

    priceEntries = [[pair, None] for pair in filePairs]
    priceTable = lambda: genPriceTable(priceEntries)
    with Live(priceTable(), refresh_per_second=4, console=console) as live:
        for index, priceEntry in enumerate(priceEntries):
            inputpath = priceEntry[0][0]
            costEstimate = priceEstimateMethod(inputpath)
            priceEntries[index][1] = costEstimate
            live.update(priceTable())

    return Confirm.ask("Accept the cost and proceed?")


def templateProcessCommand(
    processing_method: Callable[[Progress, Path, Path], None], filePairs: FilePairsType
):
    from .UI import genProgressTable
    from .fileHandler import ignoreAlreadyProcessed, ignoreAirtIgnoreFiles

    # Get only the ones that aren't processed
    filePairs = ignoreAlreadyProcessed(filePairs) # TODO this is also used before, decide where to remove it
    filePairs = ignoreAirtIgnoreFiles(filePairs)

    # TODO Move all of these tabel Live view functions into a common function for all CLI commands

    entries = [[str(pair[0]), Progress(console=console)] for pair in filePairs]
    progressTable = lambda completed: genProgressTable(entries, completed)
    outputs = []
    with Live(progressTable(0), refresh_per_second=4, console=console) as live:
        for index, entry in enumerate(entries):
            _, progress = entry
            inputFile, outputFile = filePairs[index]
            processing_method(progress, inputFile, outputFile)
            live.update(progressTable(index + 1))


@app.command(rich_help_panel="Youtube")
def downloadYoutube(
    outputfolder: InputTypes.outputfolder.value,
    urls: Annotated[List[str], typer.Argument(help="Urls to be downloaded")],
):
    """Download one or more videos from youtube"""
    from .fileFetcher import getFromYoutube
    from .UI import genProgressTable

    if outputfolder.suffix != "":
        Exception(
            "Can only write Youtube files to folder, filename will be autogenerated"
        )

    entries = [[url, Progress(console=console)] for url in urls]
    progressTable = lambda completed: genProgressTable(entries, completed)
    with Live(progressTable(0), refresh_per_second=4, console=console) as live:
        for index, entry in enumerate(entries):
            url, progress = entry
            output = getFromYoutube(url, outputfolder, progressObject=progress)
            entries[index][1] = output
            live.update(progressTable(index + 1))


@app.command(rich_help_panel="Youtube")
def downloadYoutubePlaylist(
    outputfolder: Annotated[
        Path, typer.Argument(help="Folder to place downloaded files")
    ],
    url: Annotated[str, typer.Argument(help="Url to playlist")],
):
    """Download full Youtube playlist"""
    from pytube import Playlist

    urls = Playlist(url)
    downloadYoutube(outputfolder, urls)


class ConcatMethods(str, Enum):
    moviepy = "moviepy"
    ffmpeg = "ffmpeg"


@app.command(rich_help_panel="Media file manipulation")
def concatmp4s(
    outputpath: InputTypes.outputpath_single.value,
    inputpaths: InputTypes.inputpaths.value,
    recode: Annotated[
        bool,
        typer.Option(
            help="Set if you want ffmpeg to recode the video, might solve issues, but takes much longer."
        ),
    ] = False,
    method: Annotated[
        str,
        typer.Option(
            help="Method to process concat with.",
            autocompletion=lambda incomplete: template_enum_completer(
                ConcatMethods, incomplete
            ),
        ),
    ] = "moviepy",
):
    """Concat mp4 videos into single video using either ffmpeg or moviepy-package"""
    from .fileHandler import (
        concatMp4s_ffmpeg,
        concatMp4s_moviepy,
    )
    import asyncio

    # TODO check if identity check works or if I should switch back to == for 'method' check
    if method is ConcatMethods.ffmpeg:
        with Progress(console=console) as p:
            concat_task = p.add_task("Concating the videos...", total=None)

            def initProgress(total):
                p.update(concat_task, total=total)

            def updateProg(completed):
                if completed is not None:
                    p.update(concat_task, completed=completed)

            asyncio.run(
                concatMp4s_ffmpeg(
                    inputpaths,
                    outputpath,
                    progressCallback=updateProg,
                    initProgress=initProgress,
                    recode=recode,
                )
            )
    elif method is ConcatMethods.moviepy:
        concatMp4s_moviepy(inputpaths, outputpath)


# TODO add fileFilter choice in typer function
@app.command(rich_help_panel="AI commands")
def transcribeWithAPI(
    inputpath: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
    filefilter: InputTypes.filefilter.value = FileFilters.none,
    y: InputTypes.autoaccept_prompts.value = False,
):
    """Transcribe files with OpenAI whisper API"""
    import datetime
    import time

    from .price import Price, whisper
    from .transcriber import (
        generateTranscriptWithApi,
        getTranscriptInOutPaths,
        writeToFile,
    )
    from .fileHandler import getLength_old, ignoreAlreadyProcessed, ignoreAirtIgnoreFiles

    filefilter = FileFilters.getFilter(filefilter)

    def process(progress: Progress, inputPath: Path, outputPath: Path):
        logger.info(f'Transcribing with API with file "{inputPath}"')

        try:
            start = time.time()
            transcript = generateTranscriptWithApi(inputPath, progress=progress)
            end = time.time()
            logger.info(
                f"Transcription time: {datetime.timedelta(seconds=(end-start))}"
            )
            writeToFile(transcript, outputPath)
        except Exception as err:
            logger.error(
                f"Encountered error while transcribing and saving '{outputPath}'"
            )
            logger.error(err)

    def costEstimateMethod(input: Path) -> Price:
        return whisper.calcPrice(getLength_old(input) / 60)

    filePairs = getTranscriptInOutPaths(inputpath, outputfolder, "api", filefilter)
    # Get only the ones that aren't processed
    filePairs = ignoreAlreadyProcessed(filePairs)
    filePairs = ignoreAirtIgnoreFiles(filePairs)
    if len(filePairs) == 0:
        logger.info("No files to transcribe... Exiting!")
        return

    if not y:
        accepted = templatePriceEstimate(filePairs, costEstimateMethod)
        if not accepted:
            return

    templateProcessCommand(process, filePairs)

    logger.info("Finished transcribing!")


@app.command(rich_help_panel="Media file manipulation")
def tomp3(
    inputpaths: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
    filetypes: InputTypes.tomp3_filetypes.value = [e for e in ToMp3_FileTypes],
):
    """Convert diverse mediafiles to mp3"""
    from .fileHandler import base_getInOutPaths, ignoreAlreadyProcessed, ignoreAirtIgnoreFiles

    # Convert to mp3 if there are any files that does not have a mp3
    # TODO Move to converting of types to its own command, a bit to complex to have it in this one, replace the mp4tomp3 function with this new function
    allMediaFilePairs = base_getInOutPaths(
        inputpaths, outputfolder, [f"**/*.{e.value}" for e in filetypes], "", "", "mp3"
    )
    allMediaFilePairs = ignoreAlreadyProcessed(allMediaFilePairs)
    allMediaFilePairs = ignoreAirtIgnoreFiles(allMediaFilePairs)
    if len(allMediaFilePairs) == 0:
        logger.info("No files to convert to mp3... Exiting!")
        return

    if len(allMediaFilePairs) == 0:
        logger.info("Couldn't find any unconverted files in the input paths. Exiting!")
    else:
        logger.info("Converting media files to mp3")

        def process_method(progress, inputFile, outputFile):
            from .fileHandler import ToMp3

            ToMp3(inputFile, outputFile, progress=progress)

        templateProcessCommand(process_method, allMediaFilePairs)


@app.command(rich_help_panel="AI commands")
def summarizeTranscripts(
    inputpaths: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
    pdf: InputTypes.pdf.value = False,
    y: InputTypes.autoaccept_prompts.value = False,
):
    """Sumarize text transcript using GPT-4 API"""
    from .UI import genPriceTable
    from .summarizer import (
        generatePicklePath,
        getSummaryInOutPaths,
        saveResponseToMd,
        saveObjectToPkl,
        summarizeLectureTranscript,
    )
    from .price import gpt_4_1106_preview, Price
    from .fileHandler import ignoreAlreadyProcessed, ignoreAirtIgnoreFiles

    filePairs = getSummaryInOutPaths(
        inputpaths, outputfolder, pattern="**/*.txt", prefix="summarized_"
    )
    # Get only the ones that aren't processed
    filePairs = ignoreAlreadyProcessed(filePairs)
    filePairs = ignoreAirtIgnoreFiles(filePairs)
    if len(filePairs) == 0:
        logger.info("No files to summarize... Exiting!")
        return

    def costEstimateMethod(input: Path) -> Price:
        with open(input, "r", encoding="utf-8") as f:
            length = len(f.read())
            return gpt_4_1106_preview().calcPrice(length, 3600)

    if not y:
        accepted = templatePriceEstimate(filePairs, costEstimateMethod)
        if not accepted:
            return
    
    def process(progress: Progress, inputPath: Path, outputPath: Path):
        task = progress.add_task("Summarizing...", total=None)
        # TODO add so that the full response object is saved to a pickle file, makes it easier to revisit it later on
        response = summarizeLectureTranscript(inputPath)
        # estimatedEndPrice += gpt_4_1106_preview().calcPriceFromResponse(response)
        content = response.choices[0].message.content
        saveResponseToMd(content, outputPath)
        # saveObjectToPkl(response, generatePicklePath(outputPath))
        task = progress.update(task, completed=1, total=1)

    templateProcessCommand(process, filePairs)
    # print(f"Finished, estimated spending is: {estimatedEndPrice}")

    if pdf and len(filePairs) > 0:
        mdToPdf([pair[1] for pair in filePairs])


@app.command(rich_help_panel="AI commands")
def structureTranscripts(
    inputpath: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
    pdf: InputTypes.pdf.value = False,
    y: InputTypes.autoaccept_prompts.value = False,
    attempts: int = 2
):
    """Note: Experimental! Structures a raw text transcript into paragraphs with headings using GPT-4 API"""
    from .price import gpt_4_1106_preview, Price
    from .summarizer import getSummaryInOutPaths, saveObjectToPkl
    from .fileHandler import makeSureFolderExists, ignoreAlreadyProcessed, ignoreAirtIgnoreFiles
    from .textStructurer import (
        sectionListToMarkdown,
        getStructureFromGPT,
        checkSimilarityToOriginal,
    )

    def processing(progress: Progress, inputPath: Path, outputPath: Path):
        sections, responses = getStructureFromGPT(inputPath, progress=progress)

        # TODO fix this estimated price stuff
        # estimatedEndPrice += Price.sumPrices(
        #     [
        #         gpt_4_1106_preview().calcPriceFromResponse(response)
        #         for response in responses
        #     ]
        # )

        makeSureFolderExists(outputPath)
        with open(outputPath, "w", encoding="utf-8") as file:
            file.write(sectionListToMarkdown(sections))

        saveObjectToPkl(
            responses,
            outputPath.parent / f"text-struct-responses_{outputPath.stem}.pkl",
        )
        logger.info(
            f"Finished structuring and got a similarity score between un-structured and structured text of {checkSimilarityToOriginal(inputPath, outputPath)}"
        )

    def priceEstimateMethod(input: Path) -> Price:
        with open(input, "r", encoding="utf-8") as f:
            length = len(f.read())
            costEstimate = gpt_4_1106_preview.calcPrice(length, length / 6)
            return costEstimate

    filePairs: FilePairsType = getSummaryInOutPaths(
        inputpath, outputfolder, pattern="**/*.txt", prefix="structured_"
    )
    filePairs: FilePairsType = ignoreAlreadyProcessed(filePairs)
    filePairs = ignoreAirtIgnoreFiles(filePairs)
    if len(filePairs) == 0:
        logger.info("No files to structure... Exiting!")
        return

    if not y:
        accepted = templatePriceEstimate(filePairs, priceEstimateMethod)
        if not accepted:
            return

    # estimatedEndPrice = Price(0, 0)
    logger.info("Structuring transcripts")

    # for loop to rerun the structuring since it is somewhat unstable
    for i in range(1, attempts+1):
        try:
            templateProcessCommand(processing, filePairs)
        except ValueError as e:
            logger.debug(e)
            logger.warning(f"The structuring of the transcript faile on attempt {i} of {attempts}...{' Trying again!' if i != attempts else ''}")
            if i == attempts:
                logger.error("All attempts at structuring the transcript failed... Skipping!")
        else:
            break # If it was successful exit the loop

    # print(f"Finished, estimated spending is: {estimatedEndPrice}")

    if pdf and len(filePairs) > 0:
        mdToPdf([pair[1] for pair in filePairs])


@app.command(rich_help_panel="Media file manipulation")
def trimsilence(
    inputpaths: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
    only_leading: Annotated[
        bool, typer.Option(help="Set to only trim the silence at start of clip")
    ] = False,
):
    """Trim the silence from mp4 video, AI transcription can often get confused if there are to much silence in a clip and start halucinating"""
    from .fileHandler import base_getInOutPaths, trimSilence, ignoreAlreadyProcessed, ignoreAirtIgnoreFiles
    from .UI import genProgressTable

    filePairs = base_getInOutPaths(
        inputpaths,
        outputfolder,
        "**/*.mp4",
        "trimmed_silence_" if not only_leading else "trimmed_leading_silence_",
        "",
        "mp4",
    )
    # Get only the ones that aren't processed
    filePairs = ignoreAlreadyProcessed(filePairs)
    filePairs = ignoreAirtIgnoreFiles(filePairs)

    entries = [[str(pair[0]), Progress(console=console)] for pair in filePairs]
    progressTable = lambda completed: genProgressTable(entries, completed)
    outputs = []
    with Live(progressTable(0), refresh_per_second=4, console=console) as live:
        for index, entry in enumerate(entries):
            _, progress = entry
            inputFile, outputFile = filePairs[index]
            logger.info("Structuring transcripts")

            trimSilence(
                inputFile, outputFile, only_leading=only_leading, progress=progress
            )

            live.update(progressTable(index + 1))


@app.command(rich_help_panel="Text file manipulation")
def mdToPdf(
    inputpaths: InputTypes.inputpaths.value,
    outputfolder: InputTypes.outputfolder.value = None,
):
    """Convert markdown to pdf using pandoc"""
    from .CommandRunners import runCommand
    from .fileHandler import (
        base_getInOutPaths,
        makeSureFolderExists,
        ignoreAlreadyProcessed,
        ignoreAirtIgnoreFiles
    )

    filePairs = base_getInOutPaths(inputpaths, outputfolder, "**/*.md", "", "", "pdf")
    # Get only the ones that aren't processed
    filePairs = ignoreAlreadyProcessed(filePairs)
    filePairs = ignoreAirtIgnoreFiles(filePairs)

    with Progress(console=console) as progress:
        pandoc_task = progress.add_task("Converting to pdfs....", total=len(filePairs))
        for inputFile, outputFile in filePairs:
            makeSureFolderExists(outputFile)
            runCommand(f'pandoc "{inputFile}" -o "{outputFile}"')
            progress.update(pandoc_task, advance=1)

@app.command()
def ingest_and_process():
    import importlib
    import sys

    spec = importlib.util.spec_from_file_location("ingest_and_process", f"{USER_DIR}/ingest_and_process.py")
    foo = importlib.util.module_from_spec(spec)
    sys.modules["ingest_and_process"] = foo
    spec.loader.exec_module(foo)
    foo.main()


@app.command()
def development():
    """Placeholder command for development purposes"""
    print("Dev")


@app.command()
def pdfToMd(inputfile: Path, outputfile: Path):
    from .PDFContentExtractor import pdf2md

    pdf2md(inputfile, outputfile)


